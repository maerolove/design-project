# WORKSPACE RULES

## 1. CHECK FILELIST FIRST RULE
- ВСЕГДА проверять FILELIST перед созданием директорий
- ВСЕГДА использовать пути из FILELIST вместо угадывания
- НИКОГДА не создавать директории без проверки FILELIST

## 2. CONCRETE PROPOSALS RULE
- ВСЕГДА предлагать конкретные решения перед запросом разрешения
- ВСЕГДА давать точные команды которые можно выполнить
- НИКОГДА не спрашивать "что делать" без предоставления опций

## 3. CRITICAL APPLICATION STATE RULE
- НИКОГДА не принимать ЛЮБЫЕ ошибки как нормальные
- ВСЕГДА лечить 500/404/405 ошибки как критические проблемы
- ВСЕГДА перезапускать сервисы для применения исправлений

## 4. DIAGNOSIS VS SOLUTIONS RULE
- НИКОГДА не предлагать диагностические команды как решения
- ВСЕГДА выполнять диагностику самому и предоставлять готовые решения

## 5. XML STATE MACHINE RULES (v2.0.0)
- ВСЕГДА использовать XML-based state machine вместо JSON
- ВСЕГДА валидировать XML конфигурацию через XSD схему
- ВСЕГДА использовать типизированные состояния и переходы
- НИКОГДА не использовать старые JSON state machine файлы

## 6. BUILD ASSERTIONS RULE
- ВСЕГДА проверять соответствие бэкенда и фронтенда при сборке
- ВСЕГДА валидировать XML state machine конфигурацию
- ВСЕГДА проверять API консистентность

## 7. STATE MACHINE ARCHITECTURE RULES
- ВСЕГДА разделять события и состояния четко
- ВСЕГДА использовать типизированные переходы
- ВСЕГДА валидировать состояния через XML схему
- НИКОГДА не смешивать логику состояний с бизнес-логикой

## 5. DO EXACTLY WHAT WAS ASKED RULE
- ВСЕГДА делать именно то что просили - не больше, не меньше
- НИКОГДА не пытаться делать что-то другое вместо запрошенного

## 6. ESPHome YAML Constructor Rules
- ВСЕГДА читать ./FILELIST перед каждой задачей
- ВСЕГДА спрашивать разрешение на создание файлов
- API Endpoints: https://api.kolkhoz.io (БЕЗ /api префикса)

## 7. File Creation Permission Rules
- ВСЕГДА спрашивать разрешение на создание файлов
- НИКОГДА не создавать файлы без явного разрешения пользователя

## 8. FIX OBVIOUS ERRORS RULE
- ВСЕГДА исправлять очевидные ошибки когда видишь их
- ВСЕГДА действовать немедленно на четкие сообщения об ошибках

## 9. LOCALHOST IS PRODUCTION RULE
- localhost:8000 и api.kolkhoz.io - это один и тот же сервер

## 10. NO CODE DUPLICATION RULE
- ЗАПРЕЩЕНО дублировать код во всем проекте
- ВСЕГДА создавать вспомогательные функции для общей логики

## 11. NO TEMPORARY FIXES RULE
- НЕ упрощать / НЕ делать временные отключения / НЕ комментировать код
- ВСЕГДА чинить исходную проблему
- НИКОГДА не комментировать код как "временное решение"
- ВСЕГДА анализировать проблему и рефакторить/дописывать/исправлять код

## 12. PYTHON IMPORTS RULE
- ВСЕГДА использовать абсолютные импорты от корня проекта
- НИКОГДА не использовать относительные импорты (from ..module)

## 13. Script Execution Rules
- НИКОГДА не запускать скрипты напрямую
- Только использовать механизмы таймаута, планировщики задач

## 14. STATE MACHINE USAGE RULE
- ВСЕГДА использовать константы стейт-машины для всех проверок состояний
- НИКОГДА не хардкодить строки состояний типа "valid", "invalid"

## 15. SYSTEM CONFIGURATION PROTECTION RULE
- НИКОГДА не трогать системную конфигурацию без явного разрешения
- НИКОГДА не изменять файлы nginx в /etc/nginx/

## 16. USELESS TESTS RULE
- НИКОГДА не писать тесты которые принимают любой статус как "валидный"

## 17. SINGLE XML SOURCE RULE - КЛЮЧЕВОЕ ПРАВИЛО
- СТРОГО ИСПОЛЬЗОВАТЬ ТОЛЬКО СУЩЕСТВУЮЩИЙ XML ФАЙЛ shared/stateMachineSimplified.xml
- ЗАПРЕЩЕНО КОПИРОВАТЬ XML в JavaScript файлы или другие места
- ЗАПРЕЩЕНО ДУБЛИРОВАТЬ определения состояний и переходов
- ВСЕГДА ЧИТАТЬ XML из единственного источника истины
- НИКОГДА НЕ ХАРДКОДИТЬ состояния типа 'ERROR', 'SUCCESS', 'RUNNING' в коде
- ВСЕГДА ПАРСИТЬ все состояния и переходы из XML файла
- ЕДИНЫЙ ИСТОЧНИК ИСТИНЫ - только XML файл в shared/

## 18. GIT COMMANDS PROTECTION RULE
- ЗАПРЕЩЕНО ВЫЗЫВАТЬ КОМАНДЫ ИЗ ГИТА КОТОРЫЕ ПОТЕНЦИАЛЬНО МОГУТ ИЗМЕНИТЬ СОСТОЯНИЕ РАБОЧЕЙ ДИРЕКТОРИИ
- НИКОГДА не запускать git команды которые могут изменить состояние рабочей директории
- НИКОГДА не использовать git команды которые могут изменить состояние файлов или рабочего дерева
- НИКОГДА не выполнять git команды которые могут повлиять на состояние репозитория
- ВСЕГДА использовать безопасные git команды только для чтения информации

## Запрещенные Git Команды:
- `git checkout` - может изменить состояние рабочей директории
- `git reset` - может изменить рабочую директорию и staging area
- `git clean` - может удалить файлы из рабочей директории
- `git stash` - может изменить состояние рабочей директории
- `git merge` - может изменить состояние рабочей директории
- `git rebase` - может изменить состояние рабочей директории
- `git pull` - может изменить состояние рабочей директории
- `git fetch` - может изменить состояние репозитория
- `git add` - может изменить staging area
- `git commit` - может изменить состояние репозитория
- `git push` - может изменить состояние удаленного репозитория
- `git branch` - может создать/удалить ветки
- `git tag` - может создать/удалить теги
- `git remote` - может изменить конфигурацию удаленных репозиториев

## Разрешенные Git Команды (Только для чтения):
- `git status` - показывает текущее состояние без изменения
- `git log` - показывает историю коммитов
- `git show` - показывает детали коммита
- `git diff` - показывает различия без изменения
- `git ls-files` - перечисляет файлы без изменения
- `git cat-file` - показывает содержимое файлов без изменения
- `git rev-parse` - парсит git ссылки без изменения
- `git describe` - описывает текущий коммит без изменения

## Когда нужна информация из Git:
1. **Использовать только read-only git команды** для сбора информации
2. **Никогда не изменять состояние репозитория** или рабочей директории
3. **Сообщать информацию из git** пользователю без внесения изменений
4. **Спрашивать разрешение пользователя** перед любыми git операциями которые изменяют состояние
5. **Никогда не предполагать** что пользователь хочет изменения состояния git

## Примеры ЗАПРЕЩЕННЫХ действий:
```bash
# НЕПРАВИЛЬНО - команды которые могут изменить состояние
git checkout main
git reset --hard HEAD~1
git clean -fd
git stash
git merge feature-branch
git pull origin main
git add .
git commit -m "fix"
git push origin main
```

## Примеры РАЗРЕШЕННЫХ действий:
```bash
# ПРАВИЛЬНО - только чтение информации
git status
git log --oneline -10
git show HEAD
git diff HEAD~1
git ls-files
git cat-file -p HEAD:package.json
git rev-parse HEAD
git describe --tags
```

## Исключение:
- Использовать git команды только когда явно запрошено пользователем
- Всегда спрашивать подтверждение перед любыми git операциями
- Всегда объяснять что git команда будет делать и почему
- Никогда не изменять состояние репозитория без явного разрешения

## 19. NO LOCAL FILES VIA HTTP RULE - КРИТИЧЕСКОЕ ПРАВИЛО
- СТРОГО ЗАПРЕЩЕНО загружать локальные файлы через HTTP
- НИКОГДА не использовать fallback на локальные файлы в коде
- НИКОГДА не загружать файлы из public/ или build/ директорий через HTTP
- ВСЕГДА получать данные только через API endpoints
- ВСЕГДА использовать backend для всех данных и состояний
- НИКОГДА не хардкодить локальные пути к файлам в frontend коде
- ВСЕГДА получать состояния через HTTP headers от backend
- НИКОГДА не создавать локальные копии конфигураций в frontend

## 20. DEFAULT CONFIG CONTRACT RULE - v2.0.2
- ВСЕГДА использовать флаг default=true для дефолтного конфига
- ВСЕГДА запрашивать /config/default для получения состояния COMPILED
- ВСЕГДА проверять заголовки X-Current-State, X-File-Name, X-Is-Default-Config
- ВСЕГДА устанавливать fileName при получении дефолтного конфига с состоянием COMPILED
- ВСЕГДА активировать кнопки автоматически для дефолтного конфига
- НИКОГДА не использовать хардкод для дефолтной конфигурации
- ВСЕГДА получать дефолтную конфигурацию через API endpoint

## Запрещенные действия:
- Загрузка файлов из `public/default-config.yaml`
- Загрузка файлов из `build/default-config.yaml`
- Загрузка файлов из `data/build/default-config.yaml`
- Использование `fetch('/default-config.yaml')` для локальных файлов
- Fallback на локальные файлы при ошибках API
- Хардкодинг путей к локальным файлам
- Создание локальных копий конфигураций

## Разрешенные действия:
- Получение данных только через API endpoints
- Использование backend для всех состояний
- Получение состояний через HTTP headers
- Использование API для всех конфигураций

## Примеры ЗАПРЕЩЕННЫХ действий:
```javascript
// НЕПРАВИЛЬНО - загрузка локальных файлов
fetch('/default-config.yaml')  // локальный файл
fetch('/public/config.yaml')   // локальный файл
fetch('/build/config.yaml')    // локальный файл

// НЕПРАВИЛЬНО - fallback на локальные файлы
try {
  const response = await fetch('/api/config');
} catch (error) {
  // НЕПРАВИЛЬНО - fallback на локальный файл
  const localConfig = await fetch('/default-config.yaml');
}
```

## Примеры РАЗРЕШЕННЫХ действий:
```javascript
// ПРАВИЛЬНО - только API endpoints
const response = await fetch('/api/default-config');
const config = await response.text();

// ПРАВИЛЬНО - получение состояния через headers
const state = response.headers.get('X-Current-State');
const fileName = response.headers.get('X-File-Name');
```

## Исключение:
- Использовать локальные файлы только для статических ресурсов (CSS, JS, изображения)
- Фронтенд общается с бекендом через API
- Файлы в файловой системе читаются НАПРЯМУЮ с файловой системы БЕЗ API
- Никогда не использовать локальные файлы для данных или конфигураций
- Всегда получать данные через API